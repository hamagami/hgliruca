<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="refresh" content="300;url=index6.html" />
  <title>æ¿±ä¸Šç ” å–ã‚Šçµ„ã¿ãƒ¢ãƒ‹ã‚¿</title>
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <style>
    html, body { margin:0; padding:0; font-family:sans-serif; }
    .container { display:flex; flex-direction:column; padding:10px; gap:20px; }
    .top-section { display:flex; flex-direction:row; gap:20px; }
    .left-column { width:66.6%; display:flex; flex-direction:column; gap:10px; }
    .right-column { width:33.3%; display:flex; flex-direction:column; }
    .chart-box { width:100%; height:600px; }
    .table-box { width:100%; text-align:left; }
    .table-description { background:#f0f0f0; padding:6px 10px; font-size:14px; margin-bottom:8px; }
    table { border-collapse:collapse; width:100%; text-align:center; }
    th, td { padding:6px 10px; border:1px solid #aaa; }
    .blinking { animation: blinkFade 3s ease-in-out infinite; }
    @keyframes blinkFade { 0%,100%{opacity:1;} 50%{opacity:0;} }

    /* ã†ã‚ã†ã‚çµµæ–‡å­—ï¼ˆæœ€å‰é¢ãƒ¬ã‚¤ãƒ¤ï¼‰ */
    .ghosts-layer {
      position: fixed; inset: 0; pointer-events: none; z-index: 9999; overflow: hidden;
    }
    .float-emoji {
      position: absolute;
      font-size: clamp(20px, 2.2vw, 40px);
      will-change: transform;
      filter: drop-shadow(0 2px 2px rgba(0,0,0,.2));
      opacity: .9; user-select: none;
      transition: opacity .25s linear; /* ãƒ¯ãƒ¼ãƒ—æ™‚ã®ãƒ•ã‚§ãƒ¼ãƒ‰ */
    }
    @media (prefers-reduced-motion: reduce) {
      .float-emoji { transition: transform 8s linear, opacity .25s linear; }
    }

    /* ã¨ãã©ãç¾ã‚Œã‚‹å·¨å¤§ğŸ’€ */
    .boss-emoji {
      position: absolute;
      font-size: clamp(64px, 9vw, 160px);
      will-change: transform, opacity, filter;
      filter: drop-shadow(0 6px 10px rgba(0,0,0,.35));
      opacity: 0;                 /* æœ€åˆã¯é€æ˜ï¼ˆJSã§ãƒ•ã‚§ãƒ¼ãƒ‰ï¼‰ */
      pointer-events: none;
      z-index: 10000;             /* æµ®éŠçµµæ–‡å­—ã‚ˆã‚Šä¸€æ®µä¸Š */
      transition: opacity .4s linear;
    }
    @media (prefers-reduced-motion: reduce) {
      .boss-emoji { transition: opacity .6s linear; }
    }

    #barChartContainer iframe { height: 800px !important; }
  </style>
</head>
<body onload="initPage()">
  <h1 id="title" style="text-align:center;">ãƒ¢ãƒ‹ã‚¿ãƒ¼</h1>
  <p style="text-align:center;">update per 5min <span id="real-time"></span></p>

  <div class="container">
    <div class="top-section">
      <div class="left-column">
        <!-- ã‚¹ã‚³ã‚¢ã®å¤–éƒ¨/å†…éƒ¨ãƒšãƒ¼ã‚¸ã‚’å…¥ã‚Œã‚‹ãªã‚‰ src ã‚’å·®ã—æ›¿ãˆã¦ãã ã•ã„ -->
        <div id="barChartContainer" class="chart-box">
          <iframe src="https://hamagami.github.io/hgliruca/score_graph0601a.html" width="100%" height="100%" frameborder="0"></iframe>
        </div>
        <div id="summary-chart" class="chart-box"></div>
      </div>

      <div class="right-column">
        <div class="table-box">
          <div class="table-description">
            åŒã˜ã‚¹ãƒ†ã‚¤ã‚¿ã‚¹ãŒ8æ™‚é–“ä»¥ä¸Šç¶šãå ´åˆã¯ iruca ã®ã‚¹ãƒ†ã‚¤ã‚¿ã‚¹ã«é–¢ã‚ã‚‰ãšã€Œä¸æ˜ã€ã®è¡¨ç¤ºã«ãªã‚Šã¾ã™ã€‚<br>
            iruca ã®ã‚¹ãƒ†ã‚¤ã‚¿ã‚¹ã‚’æ›´æ–°ã™ã‚‹ã¨æ–°ãŸãªã‚¹ãƒ†ã‚¤ã‚¿ã‚¹ãŒè¡¨ç¤ºã•ã‚Œã¾ã™ã€‚<br>
            8æ™‚é–“ã‚’è¶…ãˆã¦ã‚¹ãƒ†ã‚¤ã‚¿ã‚¹ãŒç¶™ç¶šã™ã‚‹å ´åˆã¯ã€åŒã˜ã‚¹ãƒ†ã‚¤ã‚¿ã‚¹ã§æ›´æ–°ã—ã¦ãã ã•ã„ã€‚
          </div>
          <table id="dataTable">
            <tr>
              <th>Name</th><th>ID</th><th>Status</th><th>Message</th><th>Update</th>
            </tr>
          </table>
        </div>
      </div>
    </div>
  </div>

  <!-- ã†ã‚ã†ã‚çµµæ–‡å­—ãƒ»å·¨å¤§ğŸ’€ã®æç”»ãƒ¬ã‚¤ãƒ¤ -->
  <div id="ghosts-layer" class="ghosts-layer" aria-hidden="true"></div>

  <script>
    /* ===== åˆæœŸåŒ– ===== */
    function initPage() {
      // ã‚¿ã‚¤ãƒˆãƒ«ã« ğŸƒğŸ‘» ã‚’ fromCodePoint ã§æ³¨å…¥ï¼ˆæ–‡å­—åŒ–ã‘å›é¿ï¼‰
      const h1 = document.getElementById('title');
      const left = String.fromCodePoint(0x1F383);  // ğŸƒ
      const right = String.fromCodePoint(0x1F47B); // ğŸ‘»
      h1.textContent = `${left} æ¿±ä¸Šç ” å–ã‚Šçµ„ã¿ãƒ¢ãƒ‹ã‚¿ãƒ¼${right}`;

      fetchTable();
      fetchTimeSeriesChart();

      const now = new Date();
      document.getElementById("real-time").innerText = now.toLocaleTimeString("ja-JP");

      startFloatingEmojis();   // ãƒˆãƒªãƒƒã‚­ãƒ¼ç§»å‹•
    }

    /* ===== å³å´ãƒ†ãƒ¼ãƒ–ãƒ« ===== */
    function fetchTable() {
      fetch("https://iruca.co/api/rooms/fc8c0139-0461-4681-af03-04063968ac05/members")
        .then(res => res.json())
        .then(data => {
          const now = new Date();
          const table = document.getElementById('dataTable');
          table.innerHTML = '<tr><th>Name</th><th>ID</th><th>Status</th><th>Message</th><th>Update</th></tr>';
          data.forEach(item => {
            const row = table.insertRow();
            const updatedTime = new Date(item.updated_at);
            const diffMs = now - updatedTime;
            const status = diffMs > 8 * 3600 * 1000 ? "ä¸æ˜" : item.status;
            row.innerHTML = `
              <td>${item.name}</td>
              <td>${item.id}</td>
              <td>${status}</td>
              <td>${item.message}</td>
              <td>${formatElapsed(diffMs)}</td>
            `;
            const cell = row.cells[2];
            if (status === "ä¸æ˜") {
              cell.classList.add("blinking");
              cell.style.backgroundColor = "gray";
            } else {
              const colors = { "åœ¨å¸­ä¸­":"blue","åœ¨å¸­":"blue","é›¢å¸­ä¸­":"salmon","é›¢å¸­":"salmon","ç ”ä¿®ä¸­":"orange","å¸°å®…":"black","å–è¾¼ä¸­":"lightyellow" };
              cell.style.backgroundColor = colors[status] || "lightgray";
              if (["åœ¨å¸­ä¸­","å¸°å®…"].includes(status)) cell.style.color = "white";
            }
          });
        });
    }
    function formatElapsed(ms) {
      const s = Math.floor(ms / 1000);
      const m = Math.floor(s / 60);
      const h = Math.floor(m / 60);
      const d = Math.floor(h / 24);
      return d > 0 ? `${d}æ—¥å‰` : h > 0 ? `${h}æ™‚é–“å‰` : m > 0 ? `${m}åˆ†å‰` : `${s}ç§’å‰`;
    }

    /* ===== å·¦ä¸‹ï¼šæ™‚ç³»åˆ—ã‚°ãƒ©ãƒ• ===== */
    function fetchTimeSeriesChart() {
      fetch("https://dl.dropbox.com/scl/fi/mc32neviwl1vydbx8c4nd/status_summary_by_time.json?rlkey=31aylckuac30jfws0l1o4y70m&dl=1")
        .then(res => res.json())
        .then(data => {
          const ts = Object.keys(data).sort();
          const zai = ts.map(t => data[t]["åœ¨å¸­ä¸­"] ?? 0);
          const ken = ts.map(t => data[t]["ç ”ä¿®ä¸­"] ?? 0);

          const shapes = [];
          const dateSet = new Set(ts.map(t => t.split("T")[0]));
          for (const date of dateSet) {
            const weekday = new Date(`${date}T00:00`).getDay();

            // å¹³æ—¥å¤œé–“ã‚’è–„ã‚°ãƒ¬ãƒ¼
            if (weekday >= 1 && weekday <= 5) {
              for (let h=0; h<24; h++) if (h>=18 || h<6) {
                const h1 = String(h).padStart(2,"0");
                const h2 = String((h+1)%24).padStart(2,"0");
                shapes.push({ type:"rect", xref:"x", yref:"paper",
                  x0:`${date}T${h1}:00`, x1:`${date}T${h2}:00`, y0:0, y1:1,
                  fillcolor:"rgba(200,200,200,0.2)", line:{width:0} });
              }
            }
            // åœŸæ—¥ã¯è–„é’ã®ç¸
            if (weekday === 0 || weekday === 6) {
              for (let h=0; h<24; h++) {
                const h1 = String(h).padStart(2,"0");
                const h2 = String((h+1)%24).padStart(2,"0");
                shapes.push({ type:"rect", xref:"x", yref:"paper",
                  x0:`${date}T${h1}:00`, x1:`${date}T${h2}:00`, y0:0, y1:1,
                  fillcolor: h%2===0 ? "rgba(150,150,255,0.10)" : "rgba(150,150,255,0.25)", line:{width:0} });
              }
            }
          }

          Plotly.newPlot("summary-chart", [
            { x: ts, y: zai, mode: "lines+markers", name: "åœ¨å¸­ä¸­", line: { color: "blue" } },
            { x: ts, y: ken, mode: "lines+markers", name: "ç ”ä¿®ä¸­", line: { color: "orange" } }
          ], {
            xaxis: { title: "æ™‚é–“", type: "date", tickformat: "%m/%d %H:%M" },
            yaxis: { title: "äººæ•°" },
            margin: { t: 30, b: 80, l: 60, r: 30 },
            shapes
          });
        });
    }

    /* ===============================
       ğŸƒğŸ‘» ãƒˆãƒªãƒƒã‚­ãƒ¼æµ®éŠï¼‹å·¨å¤§ğŸ’€
       =============================== */
    function startFloatingEmojis() {
      const layer = document.getElementById('ghosts-layer');
      if (!layer) return;

      const EMOJIS = [0x1F383, 0x1F47B]; // ğŸƒ, ğŸ‘»
      const COUNT  = 14;                  // å€‹ä½“æ•°ï¼ˆé€Ÿåº¦å¸¯ã¯å…ƒã®ã¾ã¾ã«è¦‹ãˆã‚‹è¨­å®šï¼‰
      const prefersReduced = window.matchMedia("(prefers-reduced-motion: reduce)").matches;

      const sprites = [];
      const rect = () => ({ w: layer.clientWidth, h: layer.clientHeight });

      // ãƒã‚¦ã‚¹å›é¿
      const mouse = { x: null, y: null };
      window.addEventListener('mousemove', e => { mouse.x = e.clientX; mouse.y = e.clientY; });

      // util
      const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
      const rand = (a, b) => a + Math.random() * (b - a);
      const sign = () => (Math.random() < 0.5 ? -1 : 1);

      function pickMode(s) {
        const now = performance.now();
        if (prefersReduced) {
          s.mode = "curve";
          s.modeUntil = now + rand(3000, 6500);
          s.curve = { f1: rand(0.6, 1.8), f2: rand(0.6, 1.8), gain: rand(6, 11), seed: Math.random() * 1000, dir: sign() };
          return;
        }
        const r = Math.random();
        if (r < 0.35) { // ã‚«ãƒ¼ãƒ–
          s.mode = "curve"; s.modeUntil = now + rand(3200, 7200);
          s.curve = { f1: rand(0.6, 1.8), f2: rand(0.6, 1.8), gain: rand(7, 12), seed: Math.random() * 1000, dir: sign() };
        } else if (r < 0.65) { // ã‚¸ã‚°ã‚¶ã‚°
          s.mode = "zigzag"; s.modeUntil = now + rand(2600, 5600);
          s.zig = { interval: rand(160, 320), lastFlip: performance.now(), dir: sign(), strength: rand(9, 14) };
        } else if (r < 0.9) { // å‘¨å›
          s.mode = "orbit"; s.modeUntil = now + rand(3600, 7800);
          const { w, h } = rect(); const rBase = Math.min(w, h) * rand(0.06, 0.14);
          s.orbit = { cx: rand(0, w), cy: rand(0, h), r: rBase, theta: Math.random()*Math.PI*2, omega: sign()*rand(0.35, 0.95) };
        } else { // ãƒ›ãƒãƒ¼
          s.mode = "hover"; s.modeUntil = now + rand(900, 1800);
          s.hover = { t: 0, amp: rand(5, 10) };
        }
      }

      function makeSprite() {
        const el = document.createElement('span');
        el.className = 'float-emoji';
        el.textContent = String.fromCodePoint(EMOJIS[Math.random() < 0.5 ? 0 : 1]);
        layer.appendChild(el);

        const { w, h } = rect();
        const depth = prefersReduced ? 1.0 : rand(0.7, 1.4);  // ç–‘ä¼¼Zï¼ˆã‚µã‚¤ã‚º/æœ€é«˜é€Ÿï¼‰
        const baseSpeed = prefersReduced ? 20 : rand(20, 60); // é€Ÿåº¦å¸¯
        const dir = Math.random() * Math.PI * 2;

        const s = {
          el,
          x: Math.random() * (w - 40),
          y: Math.random() * (h - 40),
          vx: Math.cos(dir) * baseSpeed,
          vy: Math.sin(dir) * baseSpeed,
          ax: 0, ay: 0, rot: rand(-5, 5),
          baseSpeed, depth, alpha: 1,
          mode: "curve", modeUntil: 0,
          curve: null, zig: null, orbit: null, hover: null
        };
        pickMode(s);
        return s;
      }

      for (let i = 0; i < COUNT; i++) sprites.push(makeSprite());

      // è¿‘æ¥å›é¿ï¼ˆè»½ã„ç¾¤ã‚Œåˆ†é›¢ï¼‰
      function separationForce(i, s, neighbors, radius = 48) {
        let fx = 0, fy = 0;
        for (let j = 0; j < neighbors.length; j++) {
          if (i === j) continue;
          const o = neighbors[j];
          const dx = s.x - o.x, dy = s.y - o.y;
          const d2 = dx*dx + dy*dy;
          if (d2 > 0 && d2 < radius*radius) {
            const d = Math.sqrt(d2);
            const w = (radius - d) / radius; // 0..1
            fx += (dx / d) * w * 40;
            fy += (dy / d) * w * 40;
          }
        }
        return { fx, fy };
      }

      let last = performance.now();
      function tick(now) {
        const dt = Math.min(0.05, (now - last) / 1000);
        last = now;
        const { w, h } = rect();

        for (let i = 0; i < sprites.length; i++) {
          const s = sprites[i];

          // ãƒ¢ãƒ¼ãƒ‰åˆ‡æ›¿
          if (now > s.modeUntil) pickMode(s);

          // ç›®æ¨™é€Ÿåº¦å¸¯ã«å¯„ã›ã‚‹
          const vmag = Math.hypot(s.vx, s.vy) || 1;
          const target = s.baseSpeed * (prefersReduced ? 0.85 : 1.0);
          const forwardBoost = Math.max(-target, Math.min((target - vmag) * 4, target));

          // æ–¹å‘ãƒ™ã‚¯ãƒˆãƒ«ã¨æ³•ç·š
          const ux = s.vx / vmag, uy = s.vy / vmag;
          const nx = -uy, ny = ux;

          let ax = ux * forwardBoost, ay = uy * forwardBoost;

          if (s.mode === "curve" && s.curve) {
            const t = (now + s.curve.seed) / 1000;
            const turn = s.curve.dir * (Math.sin(t*s.curve.f1) + 0.7*Math.cos(t*s.curve.f2)) * s.curve.gain;
            ax += nx * turn; ay += ny * turn;
          } else if (s.mode === "zigzag" && s.zig) {
            if (now - s.zig.lastFlip > s.zig.interval) {
              s.zig.lastFlip = now; s.zig.dir *= -1; s.rot += (Math.random()<0.5?-1:1) * (8 + Math.random()*10);
            }
            ax += nx * s.zig.dir * s.zig.strength * (prefersReduced ? 0.6 : 1.0);
            ay += ny * s.zig.dir * s.zig.strength * (prefersReduced ? 0.6 : 1.0);
          } else if (s.mode === "orbit" && s.orbit) {
            s.orbit.theta += s.orbit.omega * dt;
            const px = s.orbit.cx + s.orbit.r * Math.cos(s.orbit.theta);
            const py = s.orbit.cy + s.orbit.r * Math.sin(s.orbit.theta);
            const tx = -s.orbit.r * s.orbit.omega * Math.sin(s.orbit.theta);
            const ty =  s.orbit.r * s.orbit.omega * Math.cos(s.orbit.theta);
            ax += (tx - s.vx) * 0.8 + (px - s.x) * 1.2;
            ay += (ty - s.vy) * 0.8 + (py - s.y) * 1.2;
          } else if (s.mode === "hover" && s.hover) {
            s.hover.t += dt;
            ax += Math.sin(s.hover.t * 3.0) * s.hover.amp;
            ay += Math.cos(s.hover.t * 2.6) * s.hover.amp;
            ax += -s.vx * 0.9; ay += -s.vy * 0.9;
          }

          // è»½ã„ç¾¤ã‚Œåˆ†é›¢
          const sep = separationForce(i, s, sprites, 48);
          ax += sep.fx; ay += sep.fy;

          // ãƒã‚¦ã‚¹å›é¿
          if (mouse.x !== null) {
            const dx = s.x - mouse.x, dy = s.y - mouse.y;
            const d = Math.hypot(dx, dy);
            if (d < 120 && d > 0) {
              const f = (120 - d) / 120;
              ax += (dx / d) * f * 120;
              ay += (dy / d) * f * 120;
            }
          }

          // ã‚½ãƒ•ãƒˆãªå£
          const margin = 36;
          if (s.x < margin) ax += (margin - s.x) * 3;
          if (s.y < margin) ay += (margin - s.y) * 3;
          if (s.x > w - margin) ax -= (s.x - (w - margin)) * 3;
          if (s.y > h - margin) ay -= (s.y - (h - margin)) * 3;

          // ã¨ãã©ãç”»é¢ç«¯ã‹ã‚‰ãƒ¯ãƒ¼ãƒ—ã‚¤ãƒ³
          if (!prefersReduced && Math.random() < 0.04 * dt) {
            const side = Math.floor(Math.random() * 4);
            if (side === 0) { s.x = 2;     s.y = Math.random()*h; s.vx =  Math.abs(s.vx); }
            if (side === 1) { s.x = w - 2; s.y = Math.random()*h; s.vx = -Math.abs(s.vx); }
            if (side === 2) { s.y = 2;     s.x = Math.random()*w; s.vy =  Math.abs(s.vy); }
            if (side === 3) { s.y = h - 2; s.x = Math.random()*w; s.vy = -Math.abs(s.vy); }
            s.alpha = 0; // ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³
          }

          // é€Ÿåº¦æ›´æ–°ï¼†ã‚¯ãƒ©ãƒ³ãƒ—
          s.vx += ax * dt; s.vy += ay * dt;
          const vmax = (prefersReduced ? 25 : 80) * s.depth;
          const spd = Math.hypot(s.vx, s.vy) || 1;
          const k = Math.max(0, Math.min(vmax / spd, 1));
          if (k < 1) { s.vx *= k; s.vy *= k; }

          // ä½ç½®æ›´æ–°
          s.x += s.vx * dt; s.y += s.vy * dt;

          // ãƒãƒ¼ãƒ‰å£ï¼ˆãƒã‚¦ãƒ³ãƒ‰ï¼‰
          if (s.x < 0) { s.x = 0; s.vx *= -1; s.rot += 8 + Math.random()*8; }
          if (s.y < 0) { s.y = 0; s.vy *= -1; s.rot += 8 + Math.random()*8; }
          if (s.x > w - margin) { s.x = w - margin; s.vx *= -1; s.rot += 8 + Math.random()*8; }
          if (s.y > h - margin) { s.y = h - margin; s.vy *= -1; s.rot += 8 + Math.random()*8; }

          // è¦‹ãŸç›®ï¼ˆå›è»¢ãƒ»ã‚¹ã‚±ãƒ¼ãƒ«ãƒ»ãƒ•ã‚§ãƒ¼ãƒ‰ï¼‰
          const heading = Math.atan2(s.vy, s.vx);
          s.rot += (prefersReduced ? 0.04 : 0.12) * (Math.random() < 0.5 ? -1 : 1);
          s.alpha = Math.max(0, Math.min((s.alpha ?? 1) + dt * 2.5, 1));
          const scale = s.depth;
          s.el.style.opacity = (0.7 + 0.3 * s.alpha).toFixed(3);
          s.el.style.transform = `translate(${s.x}px, ${s.y}px) rotate(${(s.rot + heading*20).toFixed(2)}deg) scale(${scale.toFixed(3)})`;
        }

        requestAnimationFrame(tick);
      }
      requestAnimationFrame(tick);

      /* ==== ã“ã“ã‹ã‚‰ã€Œå·¨å¤§ğŸ’€ã€ã®ãƒ©ãƒ³ãƒ€ãƒ å‡ºç¾ ==== */
      const skullCP = 0x1F480; // ğŸ’€
      function scheduleBoss() {
        const min = prefersReduced ? 25000 : 12000;   // æœ€çŸ­é–“éš”
        const max = prefersReduced ? 40000 : 24000;   // æœ€é•·é–“éš”
        const delay = Math.floor(min + Math.random() * (max - min));
        setTimeout(() => { spawnBigSkull(); scheduleBoss(); }, delay);
      }
      function spawnBigSkull() {
        const { w: W, h: H } = rect();
        const edge = Math.floor(Math.random() * 4); // 0å·¦ 1å³ 2ä¸Š 3ä¸‹
        const margin = 40;
        let x0, y0, x1, y1;
        if (edge === 0)      { x0 = -margin;  y0 = Math.random()*H; x1 = W+margin; y1 = Math.random()*H; } // å·¦â†’å³
        else if (edge === 1) { x0 = W+margin; y0 = Math.random()*H; x1 = -margin;  y1 = Math.random()*H; } // å³â†’å·¦
        else if (edge === 2) { x0 = Math.random()*W; y0 = -margin;  x1 = Math.random()*W; y1 = H+margin; } // ä¸Šâ†’ä¸‹
        else                  { x0 = Math.random()*W; y0 = H+margin; x1 = Math.random()*W; y1 = -margin; } // ä¸‹â†’ä¸Š

        const el = document.createElement('span');
        el.className = 'boss-emoji';
        el.textContent = String.fromCodePoint(skullCP);
        layer.appendChild(el);

        const dur = 3000 + Math.random()*2500;       // 3.0ã€œ5.5ç§’
        const wobbleAmp = 18 + Math.random()*24;     // æºã‚Œ
        const rotAmp = 8 + Math.random()*10;         // å›è»¢æŒ¯ã‚Œ
        const scaleBase = 1.0 + Math.random()*0.4;   // ã‚¹ã‚±ãƒ¼ãƒ«åŸºæº–
        const t0 = performance.now();

        el.style.opacity = '0';
        let x = x0, y = y0, rot = 0, scale = scaleBase;

        function frame(t) {
          const dt = t - t0;
          const p = Math.min(1, dt / dur); // 0â†’1
          const wx = Math.sin(t / 180) * wobbleAmp;
          const wy = Math.cos(t / 200) * wobbleAmp;
          x = x0 + (x1 - x0) * p + wx;
          y = y0 + (y1 - y0) * p + wy;
          rot = Math.sin(t / 160) * rotAmp;

          // ä¸­ç›¤ã‚„ã‚„æ‹¡å¤§â†’çµ‚ç›¤æˆ»ã™æ„Ÿã˜
          const easeIn  = p < .5 ? (p*2)**2/4 : 0.25;
          const easeOut = p > .5 ? ((1-(p-.5)*2)**2)/4 : 0.25;
          scale = scaleBase + easeIn - easeOut;

          // ãƒ•ã‚§ãƒ¼ãƒ‰ï¼ˆå‰åŠIN / å¾ŒåŠOUTï¼‰
          const alpha = p < .3 ? (p/.3) : (p > .7 ? (1-(p-.7)/.3) : 1);
          el.style.opacity = alpha.toFixed(3);
          el.style.transform = `translate(${x}px, ${y}px) rotate(${rot}deg) scale(${scale})`;

          if (p < 1) requestAnimationFrame(frame);
          else el.remove();
        }
        el.style.transform = `translate(${x}px, ${y}px) rotate(0deg) scale(${scale})`;
        requestAnimationFrame(frame);
      }
      scheduleBoss();
      /* ==== ã“ã“ã¾ã§å·¨å¤§ğŸ’€ ==== */

      // ãƒªã‚µã‚¤ã‚ºè£œæ­£
      let resizeTimer = null;
      window.addEventListener('resize', () => {
        clearTimeout(resizeTimer);
        resizeTimer = setTimeout(() => {
          const { w, h } = rect();
          sprites.forEach(s => {
            s.x = Math.max(0, Math.min(s.x, w - 40));
            s.y = Math.max(0, Math.min(s.y, h - 40));
          });
        }, 150);
      });
    }

    // iframe é«˜ã•ã‚’è¦ªã«é€šçŸ¥ï¼ˆåŒãƒ‰ãƒ¡ã‚¤ãƒ³ã§ã‚ã‚Œã°æœ‰åŠ¹ï¼‰
    window.addEventListener("message", function (event) {
      if (event.data.type === "resize" && typeof event.data.height === "number") {
        const iframe = document.querySelector("iframe");
        if (iframe) iframe.style.height = event.data.height + "px";
      }
    });
  </script>
</body>
</html>
